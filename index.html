<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="fonts.css">
</head>
<body class="all">
    <header class="flex flexCols ">
        <div class="flex flexRows headerStyles">
            <div class="imagenIcono"></div>
            <h2 class="nombreBlog separadorHeaderSuperior">BOLOG</h2>
            <div class="separadorHeaderSuperior">
                <ul class="flex flexRows quitarPuntoLi ">
                    <li class="separarElemheader">Articles</li>
                    <li class="separarElemheader">Books</li>
                    <li class="separarElemheader">Workshops</li>
                    <li class="separarElemheader">Conferences</li>
                </ul>
            </div>
        </div>
        <div class="subheader">
            <ul class="flex flexRows quitarPuntoLi alinearCentro">
                <li class="separarElemSubheader">UX</li>
                <li class="separarElemSubheader">CSS</li>
                <li class="separarElemSubheader">JavaScript</li>
                <li class="separarElemSubheader">Performance</li>
                <li class="separarElemSubheader">Design</li>
                <li class="separarElemSubheader">Figma</li>
                <li class="separarElemSubheader">Wallspaper</li>
                <li class="separarElemSubheader">React</li>
                <li class="separarElemSubheader">Vue</li>
                <li class="separarElemSubheader">Web Design</li>
                <li class="separarElemSubheader">Guildes</li>
                <li class="separarElemSubheader">Bussness</li>
            </ul>
        </div>
    </header>

    <main class="flex flexRows">
        <div class="tableContent">
            <h3>Table of Contents</h3>
            <ol>
                <li>Asynchronous JavaScript</li>
                <li>Callback</li>
                <li>Promise</li>
                <li>Async/Await</li>
                <li>Event Loop</li>
                <li>References</li>
            </ol>
        </div>
        <div class="flex flexCols">
            <div class="imagen">
            </div>
            <div class="contenidoPrincipal">
                <h1>Key Concepts in JavaScript Asynchronous Programming: Callbacks, Promises, and the Event Loop</h1>
                <ol class="separar-inPC">
                    <li >
                        <h3>Asynchronous JavaScript</h3>
                        <p>
                        JavaScript is a programming language that operates in a mostly single-threaded manner, meaning it can only run one thing at a time on its main thread. However, it is often required to perform multiple tasks simultaneously, such as loading data from a server, waiting for user input, or handling timers. This is where asynchronous programming comes in. Asynchrony in JavaScript allows long-running tasks, such as HTTP requests, to not block the main flow of the program. This is crucial for user experience, especially in web applications, where waiting for a response from an operation can make the page feel slow or unresponsive (MDN Web Docs, 2023).
                        <br><br>
                        JavaScript uses different patterns to handle asynchrony, such as callbacks, promises, and async/await syntax. These mechanisms allow the language to handle time-consuming operations, such as accessing databases, interacting with external APIs, or handling user events, without stopping the main flow of execution (Flanagan, 2020).
                    </p>
                    </li>

                    <li class="separar-inPC">
                        <h3>Callback</h3>
                        <p>
                            A callback is a function that is passed as an argument to another function and is executed when an operation has completed. In JavaScript asynchronous programming, callbacks are one of the most basic and traditional ways to handle asynchrony. For example, if you make an HTTP request to get data from a server, you can pass a callback function that will be executed when that data is received.
                            <br><br>
                            However, extensive use of callbacks can lead to what is known as callback hell, which is a situation where code becomes difficult to read and maintain due to the nesting of multiple callback functions. This happens when multiple asynchronous operations depend on each other, requiring callbacks within callbacks, creating a nested code structure that is difficult to follow. For example, successive asynchronous operations can end up being multiple levels of nested functions, affecting readability (MDN Web Docs, 2023).
                            <br><br>
                            Promises emerged as a more elegant alternative to handle this problem, allowing operations to be chained together in a more structured and readable way (Davidson, 2019).
                        </p>
                    </li>

                    <li class="separar-inPC">
                        <h3>Promise</h3>
                        <p>A promise is an object in JavaScript that represents the eventual success or failure of an asynchronous operation. The promise can be in one of three states: pending, fulfilled, or rejected. When a promise is invoked, the asynchronous operation is initiated and the promise is initially in the pending state. Once the operation has completed, the promise is either resolved or rejected, and the corresponding method (then or catch) is invoked.
                            <br><br>
                            Promises have significantly improved asynchronous programming in JavaScript because they allow the outcome of an asynchronous operation to be handled in a more predictable and structured way. Furthermore, by using promises, it is possible to chain multiple asynchronous operations together without falling into the excessive nesting that characterizes callback hell. This chaining is done with the .then() methods to handle the successful resolution of a promise, and .catch() to handle errors (Flanagan, 2020).
                            <br><br>
                            A common example is the use of promises with the fetch() method, which is used to make HTTP requests. The promise returned by fetch() can be handled with then() to process the server's response and with catch() to handle any errors that occur during the request:
                            <div class="code-block">
                                <pre>
                                    <code>
                                        <span class="function-name">fetch</span>(<span class="string">'https://api.example.com/data'</span>)
                                        .<span class="function-name">then</span>(<span class="variable">response</span> => <span class="variable">response</span>.<span class="function-name">json</span>())
                                        .<span class="function-name">then</span>(<span class="variable">data</span> => console.log(<span class="variable">data</span>))
                                        .<span class="function-name">catch</span>(<span class="variable">error</span> => console.error(<span class="string">'Error:'</span>, <span class="variable">error</span>));
                                    </code>
                                </pre>
                            </div>
                            
                            Este ejemplo muestra cómo las promesas facilitan el manejo de errores y la concatenación de operaciones asíncronas (Davidson, 2019).
                            <br><br>
                            </p>
                    </li>

                    <li class="separar-inPC">
                        <h3>Async/Await</h3>
                        <p>
                            async/await is a syntax introduced in ECMAScript 2017 that provides a simpler and more readable way of working with promises. A function marked with async always returns a promise, and await is used inside async functions to pause execution until a promise is resolved or rejected.
                            <br><br>
                            The main benefit of async/await is that it allows you to write asynchronous code that looks like synchronous code. This makes it easier to read, debug, and maintain compared to using .then() and .catch() on promises. Additionally, it eliminates the need to chain promise calls together, as using await temporarily pauses the execution of the function until the promise is resolved, improving code clarity.
                            <br>
                            For example:
                            <div class="code-block">
                                <pre>
                                    <code>
                                        <span class="keyword">async</span> <span class="function-name">function</span> fetchData() {
                                            <span class="keyword">try</span> {
                                                <span class="variable">let</span> response = <span class="keyword">await</span> fetch(<span class="string">'https://api.example.com/data'</span>);
                                                <span class="variable">let</span> data = <span class="keyword">await</span> response.json();
                                                console.log(data);
                                            } <span class="keyword">catch</span> (error) {
                                                console.error(<span class="string">'Error:'</span>, error);
                                            }
                                        }
                                    </code>
                                </pre>
                            </div>
                            
                        </p>
                    </li>
                    <li class="separar-inPC">
                        <h3>Event Loop</h3>
                        <p>
                            The event loop is one of the fundamental concepts in asynchronous JavaScript execution. JavaScript uses an event-based concurrency model and an event loop that allows for non-blocking programming. Although JavaScript only has a single thread for code execution, the event loop allows code to not block execution while waiting for asynchronous tasks to complete.
                            <br><br>
                            The event loop works by managing a queue of tasks or events that are executed when the call stack is empty. Asynchronous tasks such as timer callbacks or HTTP request responses are placed in the queue and the event loop pushes them onto the call stack once all current tasks have been processed (Node.js Docs, 2023).
                            <br><br>
                            For example, when you call setTimeout() in JavaScript, the associated callback function is placed in the task queue and executed when the main thread is free, after all other synchronous tasks have been processed.
                            <br><br>
                            The event loop is the reason why JavaScript can perform tasks such as user interface manipulation, handling user events, and processing data without blocking the main thread (Davidson, 2019).
                        </p>
                    </li>
                </ol>
                <h2 class="separar-inPC">References</h2>
                <ul class="references-list">
                    <li>
                        Davidson, T. (2019). JavaScript Async and Promises: Asynchronous Code Like a Boss. Smashing Magazine. 
                        <a href="https://www.smashingmagazine.com/2019/10/javascript-async-promises/">https://www.smashingmagazine.com/2019/10/javascript-async-promises/</a>
                    </li>
                    <li>
                        Flanagan, D. (2020). JavaScript: The Definitive Guide (7th ed.). O'Reilly Media.
                    </li>
                    <li>
                        MDN Web Docs. (2023). Asynchronous JavaScript. 
                        <a href="https://developer.mozilla.org/es/docs/Learn/JavaScript/Asynchronous/Conceptos_basicos">https://developer.mozilla.org/es/docs/Learn/JavaScript/Asynchronous/Conceptos_basicos</a>
                    </li>
                    <li>
                        Node.js Docs. (2023). The Node.js Event Loop, Timers, and process.nextTick(). 
                        <a href="https://nodejs.org/es/docs/guides/event-loop-timers-and-nexttick/">https://nodejs.org/es/docs/guides/event-loop-timers-and-nexttick/</a>
                    </li>
                </ul>
            </div>
        </div>
    </main>

    <footer class="footer">
        <div class="footer-section">
            <p>&copy; 2024 Somil Sandoval Diaz. All rights reserved.</p>
        </div>
        
        <div class="footer-section">
            <a href="#">Privacy Policy</a> | 
            <a href="#">Terms of Service</a> | 
            <a href="#">Contact Us</a>
        </div>
    
        <div class="footer-icons">
            <a href="https://facebook.com" target="_blank">Facebook</a>
            <a href="https://twitter.com" target="_blank">Twitter</a>
            <a href="https://instagram.com" target="_blank">Instagram</a>
            <a href="https://linkedin.com" target="_blank">LinkedIn</a>
        </div>
    </footer>
</body>
</html>